<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="readability-verification" content="cG3MqZcEVveKZ6mnEFkePAL3Ug79Jxxp5Fn27CM7" />
<title>JS ⊢ Proving Type Inequality in C++</title>
<link rel="stylesheet" type="text/css" href="../css/screen.css" />
<link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<link rel="stylesheet" type="text/css" href="../css/coqdoc.css" />
<style type="text/css">
    @import url(http://nmashton.ca/css/gloss-0.0.1.css);
</style>
<script type="text/javascript" src="http://code.jquery.com/jquery-1.8.3.min.js"></script>
<script type="text/javascript" src="http://nmashton.ca/js/gloss-0.0.1.js"></script>
<link rel="alternate" type="application/rss+xml" title="Jonathan Sterling" href="../rss.xml" />


<!--[if IE]>
  <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
<!--[if lte IE 7]>
  <script src="js/IE8.js" type="text/javascript"></script><![endif]-->
<!--[if lt IE 7]>
<link rel="stylesheet" type="text/css" media="all" href="css/ie6.css"/><![endif]-->

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  showMathMenu: false,
  showProcessingMessages: false,
  messageStyle: "none",
  'HTML-CSS': {
    availableFonts: [],
    webFont: 'TeX',
  },
  TeX: {
    Macros: {
      gk: ["\\style{font-family:Junicode!important; font-size:1.3em;}{\\text{#1}}", 1]
    }
  }
});
</script>
</head>
<body>

<header>
<h1><a href="../index.html"><span class="title">Proving Type Inequality in C++.</span></a></h1>
</header>

<section class="post">
<article><p>It is trivial to prove type equality in Haskell (to the extent that anything is every “proved” in Haskell). As for proving type <em>inequality</em>, Conor McBride <a href="http://stackoverflow.com/a/14277376/125361">demonstrates</a> that this is possible to do using type families. Today, I’d like to show some techniques for doing the same in C++ with templates.</p>
<!--more-->

<p>First, let’s come up with some notion of equality. We’re going to base our encoding off of the following pseudocode:</p>
<p><span class="math">\[\begin{align}
\frac{\vdash\sigma : \star \qquad \vdash\tau : \star}{\vdash \sigma
\equiv \tau : \star}\tag{≡-type}
\end{align}\]</span></p>
<p><span class="math">\[\begin{align}
\frac{\vdash\sigma : \star}{\vdash\ \hbox{refl} :
\sigma\equiv\sigma}\tag{≡-intro}
\end{align}\]</span></p>
<p><span class="math">\[\begin{align}
\frac{\vdash x : \sigma \qquad \sigma\equiv\tau}{\vdash x : \tau}\tag{≡-conversion}
\end{align}\]</span></p>
<p><span class="math">\[\begin{align}
\frac{\vdash \sigma\equiv\tau \qquad \vdash f : \star\to\star}{\vdash f(\sigma)\equiv f(\tau)}\tag{≡-congruence}
\end{align}\]</span></p>
<p><span class="math">\[\begin{align}
\frac{\vdash \sigma\equiv\tau \qquad \vdash f : \star\to\star\qquad
\vdash x : f(\sigma)}{\vdash x : f(\tau)}
\tag{≡-transport}
\end{align}\]</span></p>
<h3 id="encoding-equality">Encoding Equality</h3>
<pre class="sourceCode Cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;functional&gt;</span>
<span class="kw">namespace</span> Equality {</code></pre>
<p>There is no term in <code>∀ A B. Eq&lt;A,B&gt;</code>; constructors are automatically generated by C++, so we must explicitly delete it.</p>
<pre class="sourceCode Cpp"><code class="sourceCode cpp">    <span class="kw">template</span> &lt;<span class="kw">class</span> A, <span class="kw">class</span> B&gt;
    <span class="kw">struct</span> Eq { Eq() = <span class="kw">delete</span>; };</code></pre>
<p>According to <span class="math">\(\hbox{≡-intro}\)</span> rule above, we can construct a term in <code>∀ A. Eq&lt;A,A&gt;</code>:</p>
<pre class="sourceCode Cpp"><code class="sourceCode cpp">    <span class="kw">template</span> &lt;<span class="kw">class</span> A&gt;
    <span class="kw">struct</span> Eq&lt;A,A&gt; { Eq() {} };</code></pre>
<p>Casting as in <span class="math">\(\hbox{≡-conversion}\)</span> is morally correct, but not provable in C++, lacking any notion of dependent pattern matching and refinement. Trusting in the soundness of our axioms, we do an unsafe cast under the hood, given an equality proof.</p>
<pre class="sourceCode Cpp"><code class="sourceCode cpp">    <span class="kw">template</span> &lt;<span class="kw">class</span> A, <span class="kw">class</span> B&gt;
    B cast(Eq&lt;A,B&gt; refl, A x) {
        <span class="kw">return</span> *(B*)&amp;x;
    }</code></pre>
<p>Likewise, <span class="math">\(\hbox{≡-congruence}\)</span> is not provable in C++ for the same reasons; we’ll have to fudge the implementation, trusting the axioms.</p>
<pre class="sourceCode Cpp"><code class="sourceCode cpp">    <span class="kw">template</span> &lt;<span class="kw">template</span> &lt;<span class="kw">class</span>&gt; <span class="kw">class</span> F, <span class="kw">class</span> A, <span class="kw">class</span> B&gt;
    Eq&lt;F&lt;A&gt;,F&lt;B&gt;&gt; cong(Eq&lt;A,B&gt; refl) {
        <span class="kw">auto</span> fudge = Eq&lt;F&lt;A&gt;,F&lt;A&gt;&gt;();
        <span class="kw">return</span> *(Eq&lt;F&lt;A&gt;,F&lt;B&gt;&gt;*)&amp;fudge;
    }</code></pre>
<p>Finally, <span class="math">\(\hbox{≡-transport}\)</span> can be defined in terms of what we’ve already done:</p>
<pre class="sourceCode Cpp"><code class="sourceCode cpp">    <span class="kw">template</span> &lt;<span class="kw">template</span> &lt;<span class="kw">class</span>&gt; <span class="kw">class</span> F, <span class="kw">class</span> A, <span class="kw">class</span> B&gt;
    F&lt;B&gt; transport(Eq&lt;A,B&gt; refl, F&lt;A&gt; x) {
        <span class="kw">return</span> cast(cong&lt;F&gt;(refl), d);
    }
}</code></pre>
<h3 id="encoding-some-logic">Encoding some Logic</h3>
<p>In a quick digression that will prove necessary shortly, let’s define some basic types that will correspond to falsity, truth and negation:</p>
<pre class="sourceCode Cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> Logic {</code></pre>
<p>In the BHK interpretation of intuitionistic logic, falsity is simply a proposition that has no proofs. So we can just provide a type without any constructors:</p>
<pre class="sourceCode Cpp"><code class="sourceCode cpp">    <span class="kw">struct</span> Empty { Empty() = <span class="kw">delete</span>; };</code></pre>
<p>To make a provable proposition, we can provide a type that does have a constructor:</p>
<pre class="sourceCode Cpp"><code class="sourceCode cpp">    <span class="kw">struct</span> Unit { Unit () {} };</code></pre>
<p>For one proposition <span class="math">\(P\)</span> to imply another proposition <span class="math">\(Q\)</span>, we provide a function which converts proofs of <span class="math">\(P\)</span> to proofs of <span class="math">\(Q\)</span>:</p>
<pre class="sourceCode Cpp"><code class="sourceCode cpp">    <span class="kw">template</span> &lt;<span class="kw">class</span> P, <span class="kw">class</span> Q&gt;
    <span class="kw">using</span> Implication = std::function&lt;Q(P)&gt;;</code></pre>
<p>Finally, we use <em>reductio ad absurdum</em> to refute a proposition:</p>
<pre class="sourceCode Cpp"><code class="sourceCode cpp">    <span class="kw">template</span> &lt;<span class="kw">class</span> P&gt;
    <span class="kw">using</span> Not = Implication&lt;P,Empty&gt;;
}</code></pre>
<h3 id="discrimination-refuting-equalities">Discrimination: Refuting Equalities</h3>
<p>Finally, we are ready to encode the central conceit.</p>
<pre class="sourceCode Cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> Refute {
    <span class="kw">using</span> <span class="kw">namespace</span> Logic;
    <span class="kw">using</span> <span class="kw">namespace</span> Equality;</code></pre>
<p>First, we shall encode some type-level discrimination functions; so that we can branch on types:</p>
<pre class="sourceCode Cpp"><code class="sourceCode cpp">    <span class="kw">template</span> &lt;<span class="kw">class</span> A, <span class="kw">class</span> B, <span class="kw">class</span> T, <span class="kw">class</span> CaseA, <span class="kw">class</span> CaseB&gt; <span class="kw">struct</span> If;

    <span class="kw">template</span> &lt;<span class="kw">class</span> A, <span class="kw">class</span> B, <span class="kw">class</span> CaseA, <span class="kw">class</span> CaseB&gt;
    <span class="kw">struct</span> If&lt;A,B,A,CaseA,CaseB&gt; {
        <span class="kw">using</span> apply = CaseA;
    };

    <span class="kw">template</span> &lt;<span class="kw">class</span> A, <span class="kw">class</span> B, <span class="kw">class</span> CaseA, <span class="kw">class</span> CaseB&gt;
    <span class="kw">struct</span> If&lt;A,B,B,CaseA,CaseB&gt; {
        <span class="kw">using</span> apply = CaseB;
    };</code></pre>
<p>Because of some quirks in the way that C++ handles partial template application, we must provide a bit of indirection for what comes next:</p>
<pre class="sourceCode Cpp"><code class="sourceCode cpp">    <span class="kw">template</span> &lt;<span class="kw">class</span> A, <span class="kw">class</span> B&gt;
    <span class="kw">struct</span> Discriminate {
        <span class="kw">template</span> &lt;<span class="kw">class</span> T&gt;
        <span class="kw">using</span> apply = <span class="kw">typename</span> If&lt;A,B,T,Unit,Empty&gt;::apply;
    };</code></pre>
<p>If a path from <code>A</code> to <code>B</code> (in <code>Eq&lt;A,B&gt;</code>) actually exists, then we should be able to transport any <code>F&lt;A&gt;</code> to <code>F&lt;B&gt;</code>; in this way, we can convert a proof of <code>Eq&lt;A,B&gt;</code> to a proof of <code>Empty</code>.</p>
<pre class="sourceCode Cpp"><code class="sourceCode cpp">    <span class="kw">template</span> &lt;<span class="kw">class</span> A, <span class="kw">class</span> B&gt;
    <span class="kw">typename</span> Discriminate&lt;A,B&gt;::<span class="kw">template</span> apply&lt;B&gt; refute_equality(Eq&lt;A,B&gt; refl) {
        <span class="kw">return</span> transport&lt;Discriminate&lt;A,B&gt;::<span class="kw">template</span> apply&gt;(refl, Unit());
    }
}</code></pre>
<h3 id="the-payoff">The Payoff</h3>
<p>Now, given some different types, we can prove that they are not equal using the kit that we have come up with so far:</p>
<pre class="sourceCode Cpp"><code class="sourceCode cpp"><span class="dt">void</span> demonstration() {
    <span class="kw">using</span> Equality::Eq;
    <span class="kw">using</span> Logic::Not;
    <span class="kw">using</span> Refute::refute_equality;

    <span class="kw">struct</span> Dog;
    <span class="kw">struct</span> Cat;

    Not&lt;Eq&lt;Cat,Dog&gt;&gt; cat_is_not_dog = refute_equality&lt;Cat,Dog&gt;;
}</code></pre>
<p>The term <code>cat_is_not_dog</code> serves as a witness that <code>Cat</code> and <code>Dog</code> are different types!</p></article>
<h1>Want to comment?</h1>
<p> I’m @jonsterling on <a href="http://www.twitter.com/jonsterling">Twitter</a>.


<script src="//static.getclicky.com/js" type="text/javascript"></script>
<script type="text/javascript">try{ clicky.init(66625087);
    }catch(e){}</script>
<noscript><p><img alt="Clicky" width="1" height="1" src="//in.getclicky.com/66625087ns.gif" /></p></noscript>

<a rel="me" href="http://twitter.com/jonsterling"></a>
<a rel="me" href="https://alpha.app.net/jonsterling"></a>
</body>
</html>

