<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="readability-verification" content="cG3MqZcEVveKZ6mnEFkePAL3Ug79Jxxp5Fn27CM7" />
<title>JS ⊢ Pi &amp; Sigma: Adding Universe Polymorphism</title>
<link rel="stylesheet" type="text/css" href="../css/screen.css" />
<link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<link rel="stylesheet" type="text/css" href="../css/coqdoc.css" />
<style type="text/css">
    @import url(http://nmashton.ca/css/gloss-0.0.1.css);
</style>
<script type="text/javascript" src="http://code.jquery.com/jquery-1.8.3.min.js"></script>
<script type="text/javascript" src="http://nmashton.ca/js/gloss-0.0.1.js"></script>
<link rel="alternate" type="application/rss+xml" title="Jonathan Sterling" href="../rss.xml" />


<!--[if IE]>
  <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
<!--[if lte IE 7]>
  <script src="js/IE8.js" type="text/javascript"></script><![endif]-->
<!--[if lt IE 7]>
<link rel="stylesheet" type="text/css" media="all" href="css/ie6.css"/><![endif]-->

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  'HTML-CSS': {
    availableFonts: [],
    webFont: 'TeX'
  }
});
</script>
</head>
<body>

<header>
<h1><a href="../index.html"><span class="title">Pi &amp; Sigma: Adding Universe Polymorphism.</span></a></h1>
</header>

<section class="post">
<article><p><a href="http://www.jonmsterling.com/posts/2012-09-07-pi-is-for-power-sigma-for-product.html">Last time</a>, I showed how <span class="math">\(\prod\)</span> and <span class="math">\(\sum\)</span> types generalize the cartesian power (function arrow) and the cartesian product respectively. Unfortunately, the Agda implementation I provided requires the first element in the <span class="math">\(\sum\)</span>-pair to be a term of a type, which precludes the encoding of existentials which could be used to abstract away a type (which is a term of a kind). Today, I’ll show how to fix this using Universe Polymorphism.</p>
<!--more-->

<blockquote>
<p><strong>What is universe polymorphism?</strong> In our theory, values inhabit types, types inhabit kinds, and so forth (it’s larger <em>sorts</em> all the way up!) This stratification wraps up the idea that a proposition about a set of terms is their type; and so, if it’s possible to have a proposition about types, then that means they must have kinds; and if we can make propositions about kinds, then they must inhabit terms of some larger space, and so forth. It’s often useful to make a proposition that applies to multiple universes; this is what allows us to, for instance, use the same specification for encoding a list of values and a list of types.</p>
</blockquote>
<h3 id="approaches-to-universe-levels">Approaches to Universe Levels</h3>
<p>The first approach to universe levels is just to ignore them altogether:</p>
<p><span class="math">\[\begin{align}
    \tau \in \textbf{Set} \in \textbf{Set} \in \textbf{Set} \in \textbf{Set}\cdots
    \tag{Dragons!}
\end{align}\]</span></p>
<p>This is unfortunate, and will allow us to prove any proposition, even if it is false. Agda provides this feature with its <code>--type-in-type</code> option; even though it would “solve” our problem, it is clearly a nonstarter.</p>
<p>The default approach in Agda is to universe polymorphism, where you parameterize <code>Set</code> with a level index, generating the hierarchy we know and love:</p>
<p><span class="math">\[\begin{align}
    \tau \in \textbf{Set}_0 \in \textbf{Set}_1 \in \textbf{Set}_2\cdots
    \tag{Stratification}
\end{align}\]</span>.</p>
<p>The last approach, which is adopted by Idris, is <strong>Cumulativity</strong>.<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup> Cumulativity adds a typing rule that says that terms in one level are also terms in higher levels:<sup><a href="#fn2" class="footnoteRef" id="fnref2">2</a></sup></p>
<p><span class="math">\[\begin{align}
    \frac{\Gamma \vdash \tau \in \text{Set}_\ell}
         {\Gamma \vdash \tau \in \text{Set}_{\ell+1}} \tag{Cumulativity
Rule}
\end{align}\]</span></p>
<p>Since we’re working in Agda, we will be using the explicit level-parameterization approach.</p>
<h3 id="adding-universe-polymorphism-to-prod-and-sum">Adding Universe Polymorphism to <span class="math">\(\prod\)</span> and <span class="math">\(\sum\)</span></h3>
<p>Without further delay, let’s rewrite yesterday’s code using universe polymorphism:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">SigmaPi</span> <span class="kw">where</span>
  open <span class="kw">import</span> Level using (_⊔_)

  <span class="co">-- We specify the universe levels as implicit parameters to the type</span>
  <span class="co">-- constructor. Then, we parameterize instances of `Set` with them.</span>

  <span class="co">-- Our parameters may live in different universes, so the resulting</span>
  <span class="co">-- type needs to live in the smallest universe that can hold both.</span>
  <span class="co">-- The _⊔_ operator selects the maximum level of its arguments.</span>
  record Π {l m} (α <span class="fu">:</span> <span class="dt">Set</span> l) (β <span class="fu">:</span> α <span class="ot">→</span> <span class="dt">Set</span> m) <span class="fu">:</span> <span class="dt">Set</span> (l ⊔ m) <span class="kw">where</span>
    constructor Λ
    field _<span class="fu">$</span>_ <span class="fu">:</span> ((x <span class="fu">:</span> α) <span class="ot">→</span> β x)
  open Π public

  record Σ {l m} (α <span class="fu">:</span> <span class="dt">Set</span> l) (β <span class="fu">:</span> α <span class="ot">→</span> <span class="dt">Set</span> m) <span class="fu">:</span> <span class="dt">Set</span> (l ⊔ m) <span class="kw">where</span>
    constructor _,_
    field
      <span class="fu">fst</span> <span class="fu">:</span> α
      <span class="fu">snd</span> <span class="fu">:</span> β <span class="fu">fst</span>
  open Σ public

  <span class="co">-- Not much change is needed to make our special cases work in the</span>
  <span class="co">-- new system.</span>
  _<span class="fu">~&gt;</span>_ <span class="fu">:</span> <span class="ot">∀</span> {ℓ} <span class="ot">→</span> <span class="dt">Set</span> ℓ <span class="ot">→</span> <span class="dt">Set</span> ℓ <span class="ot">→</span> <span class="dt">Set</span> ℓ
  _<span class="fu">~&gt;</span>_ α β <span class="fu">=</span> Π α (λ _ <span class="ot">→</span> β)

  _×_ <span class="fu">:</span> <span class="ot">∀</span> {ℓ} <span class="ot">→</span> <span class="dt">Set</span> ℓ <span class="ot">→</span> <span class="dt">Set</span> ℓ <span class="ot">→</span> <span class="dt">Set</span> ℓ
  _×_ α β <span class="fu">=</span> Σ α (λ _ <span class="ot">→</span> β)</code></pre>
<p>Now, we should be able to existentially abstract out both types <em>and</em> values (previously, we could only abstract out values). Let’s build up some tackle:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell">  <span class="co">-- `exists` &quot;forgets&quot; a parameter of its argument; so, `exists P`</span>
  <span class="co">-- would represent translate to `∃ α. P(α)` in logic.</span>
  exists <span class="fu">:</span> <span class="ot">∀</span> {l m} {α <span class="fu">:</span> <span class="dt">Set</span> l} <span class="ot">→</span> (α <span class="ot">→</span> <span class="dt">Set</span> m) <span class="ot">→</span> <span class="dt">Set</span> (l ⊔ m)
  exists <span class="fu">=</span> Σ _

  <span class="co">-- We can define some syntactic sugar to get a cleaner, more familiar</span>
  <span class="co">-- abstraction, which allows us to write `∃ α ⇒ P α ℕ` rather than</span>
  <span class="co">-- the more verbose `exists (λ α → P α ℕ)`.</span>
  syntax exists (λ α <span class="ot">→</span> <span class="dt">P</span>) <span class="fu">=</span> <span class="ot">∃</span> α <span class="ot">⇒</span> <span class="dt">P</span>

  <span class="co">-- Remember, an existential is just a pair containing a value on the</span>
  <span class="co">-- left and a predicate that it satisfies on the right. To simplify</span>
  <span class="co">-- introduction, we can create a little function `∃|` that will infer</span>
  <span class="co">-- the first parameter (such as the length of a vector, or some type</span>
  <span class="co">-- parameter).</span>
  <span class="ot">∃</span>| <span class="fu">:</span> <span class="ot">∀</span> {l m} {α <span class="fu">:</span> <span class="dt">Set</span> l} {β <span class="fu">:</span> α <span class="ot">→</span> <span class="dt">Set</span> m} {x} <span class="ot">→</span> β x <span class="ot">→</span> exists β
  <span class="ot">∃</span>| x <span class="fu">=</span> _ , x</code></pre>
<h3 id="hard-work-pays-off-an-example-use">Hard work pays off: an example use</h3>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Examples</span> <span class="kw">where</span>
  open <span class="kw">import</span> SigmaPi
  open <span class="kw">import</span> Data.Nat

  <span class="kw">data</span> <span class="dt">Bovine</span> <span class="fu">:</span> <span class="dt">Set</span> <span class="kw">where</span>
    <span class="dt">Bessie</span>  <span class="fu">:</span> <span class="dt">Bovine</span>
    <span class="dt">Brownie</span> <span class="fu">:</span> <span class="dt">Bovine</span>
    <span class="dt">Macy</span>    <span class="fu">:</span> <span class="dt">Bovine</span>

  <span class="co">-- First, let's define a dependent vector type, indexed by its length.</span>
  <span class="kw">data</span> <span class="dt">Vector</span> {ℓ} (α <span class="fu">:</span> <span class="dt">Set</span> ℓ) <span class="fu">:</span> ℕ <span class="ot">→</span> <span class="dt">Set</span> ℓ <span class="kw">where</span>
    []  <span class="fu">:</span> <span class="dt">Vector</span> α <span class="dv">0</span>
    _<span class="ot">∷</span>_ <span class="fu">:</span> {n <span class="fu">:</span> ℕ} <span class="ot">→</span> α <span class="ot">→</span> <span class="dt">Vector</span> α n <span class="ot">→</span> <span class="dt">Vector</span> α (n <span class="fu">+</span> <span class="dv">1</span>)
  <span class="kw">infixr</span> <span class="dv">5</span> _<span class="ot">∷</span>_

  <span class="fu">all-</span>bovines <span class="fu">:</span> <span class="dt">Vector</span> <span class="dt">Bovine</span> <span class="dv">3</span>
  <span class="fu">all-</span>bovines <span class="fu">=</span> <span class="dt">Bessie</span> <span class="ot">∷</span> <span class="dt">Brownie</span> <span class="ot">∷</span> <span class="dt">Macy</span> <span class="ot">∷</span> []

  <span class="co">-- We can make a vector's length abstract (where the length is a value</span>
  <span class="co">-- rather than a type):</span>
  <span class="ot">∃</span>-value<span class="fu">-</span>ex <span class="fu">:</span> <span class="ot">∃</span> n <span class="ot">⇒</span> <span class="dt">Vector</span> <span class="dt">Bovine</span> n
  <span class="ot">∃</span>-value<span class="fu">-</span>ex <span class="fu">=</span> <span class="ot">∃</span>| <span class="fu">all-</span>bovines

  <span class="co">-- We can now also make the type of a vector's elements abstract:</span>
  <span class="ot">∃</span>-<span class="kw">type</span><span class="fu">-</span>ex <span class="fu">:</span> <span class="ot">∃</span> α <span class="ot">⇒</span> <span class="dt">Vector</span> α <span class="dv">3</span>
  <span class="ot">∃</span>-<span class="kw">type</span><span class="fu">-</span>ex <span class="fu">=</span> <span class="ot">∃</span>| <span class="fu">all-</span>bovines</code></pre>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="http://idris-lang.org">http://idris-lang.org</a><a href="#fnref1">↩</a></p></li>
<li id="fn2"><p><a href="http://www.e-pig.org/epilogue/?p=857">http://www.e-pig.org/epilogue/?p=857</a><a href="#fnref2">↩</a></p></li>
</ol>
</div></article>
<h1>Want to comment?</h1>
<p> I’m @jonsterling on <a href="http://www.twitter.com/jonsterling">Twitter</a> and <a href="https://alpha.app.net/jonsterling">App.net</a>.</p>


<script src="//static.getclicky.com/js" type="text/javascript"></script>
<script type="text/javascript">try{ clicky.init(66625087);
    }catch(e){}</script>
<noscript><p><img alt="Clicky" width="1" height="1" src="//in.getclicky.com/66625087ns.gif" /></p></noscript>

<a rel="me" href="http://twitter.com/jonsterling"></a>
<a rel="me" href="https://alpha.app.net/jonsterling"></a>
</body>
</html>

