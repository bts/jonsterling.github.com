<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="readability-verification" content="cG3MqZcEVveKZ6mnEFkePAL3Ug79Jxxp5Fn27CM7" />
<title>JS ⊢ Isomorphism Implies Equality for Finite Sets</title>
<link rel="stylesheet" type="text/css" href="../css/screen.css" />
<link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<link rel="stylesheet" type="text/css" href="../css/coqdoc.css" />
<style type="text/css">
    @import url(http://nmashton.ca/css/gloss-0.0.1.css);
</style>
<script type="text/javascript" src="http://code.jquery.com/jquery-1.8.3.min.js"></script>
<script type="text/javascript" src="http://nmashton.ca/js/gloss-0.0.1.js"></script>
<link rel="alternate" type="application/rss+xml" title="Jonathan Sterling" href="../rss.xml" />


<!--[if IE]>
  <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
<!--[if lte IE 7]>
  <script src="js/IE8.js" type="text/javascript"></script><![endif]-->
<!--[if lt IE 7]>
<link rel="stylesheet" type="text/css" media="all" href="css/ie6.css"/><![endif]-->

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  'HTML-CSS': {
    availableFonts: [],
    webFont: 'TeX'
  }
});
</script>
</head>
<body>

<header>
<h1><a href="../index.html"><span class="title">Isomorphism Implies Equality for Finite Sets.</span></a></h1>
</header>

<section class="post">
<article><p>In a sufficiently simple type theory, it’s trivial to demonstrate that adding an axiom that isomorphism implies equality is safe and computable. Today we demonstrate this for a universe of finite sets without induction. Perhaps will help some people start to feel why the Voevodsky’s Univalence Axiom is probably morally correct.</p>
<!--more-->

<p>We follow the <a href="http://sneezy.cs.nott.ac.uk/darcs/RDTP/2ndmeeting/desc.pdf">Epigram Posse</a> in defining enumerations (<code>EnumU</code>) by their tags (<code>UId</code>) and constructors (<code>EnumT</code>).</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Uni</span> <span class="kw">where</span>
  postulate <span class="dt">String</span> <span class="fu">:</span> <span class="dt">Set</span>
  <span class="ot">{-# BUILTIN STRING String #-}</span>

  <span class="kw">data</span> <span class="dt">UId</span> <span class="fu">:</span> <span class="dt">Set</span> <span class="kw">where</span>
    ‵_ <span class="fu">:</span> <span class="dt">String</span> <span class="ot">→</span> <span class="dt">UId</span>

  <span class="kw">infixr</span> <span class="dv">10</span> _<span class="ot">∷</span>_
  <span class="kw">data</span> <span class="dt">EnumU</span> <span class="fu">:</span> <span class="dt">Set</span> <span class="kw">where</span>
    [] <span class="fu">:</span> <span class="dt">EnumU</span>
    _<span class="ot">∷</span>_ <span class="fu">:</span> <span class="dt">UId</span> <span class="ot">→</span> <span class="dt">EnumU</span> <span class="ot">→</span> <span class="dt">EnumU</span>

  <span class="kw">data</span> <span class="dt">EnumT</span> <span class="fu">:</span> <span class="dt">EnumU</span> <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span>
    ‵0   <span class="fu">:</span> {t <span class="fu">:</span> <span class="dt">UId</span>} {<span class="dt">E</span> <span class="fu">:</span> <span class="dt">EnumU</span>} <span class="ot">→</span> <span class="dt">EnumT</span> (t <span class="ot">∷</span> <span class="dt">E</span>)
    ‵1<span class="fu">+</span>_ <span class="fu">:</span> {t <span class="fu">:</span> <span class="dt">UId</span>} {<span class="dt">E</span> <span class="fu">:</span> <span class="dt">EnumU</span>} (n <span class="fu">:</span> <span class="dt">EnumT</span> <span class="dt">E</span>) <span class="ot">→</span> <span class="dt">EnumT</span> (t <span class="ot">∷</span> <span class="dt">E</span>)</code></pre>
<p>Our enumerations subsume the common <code>Zero</code> and <code>One</code> types:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="ot">`zero = []</span>
<span class="ot">  ‵one = ‵&quot;tt&quot; ∷ []</span>

<span class="ot">  ‵tt : EnumT ‵one</span>
<span class="ot">  ‵tt = ‵0</span></code></pre>
<p>Now, we can define our closed type theory.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  mutual
    <span class="kw">infixl</span> <span class="dv">10</span> _⊗_
    <span class="kw">infixr</span> <span class="dv">10</span> _≡_
    <span class="kw">infixr</span> <span class="dv">10</span> _≃_

    <span class="kw">data</span> <span class="dt">Ty</span> <span class="fu">:</span> <span class="dt">Set</span> <span class="kw">where</span>
      set <span class="fu">:</span> <span class="dt">Ty</span>
      fin <span class="fu">:</span> <span class="dt">EnumU</span> <span class="ot">→</span> <span class="dt">Ty</span>
      _⊗_ <span class="fu">:</span> <span class="dt">Ty</span> <span class="ot">→</span> <span class="dt">Ty</span> <span class="ot">→</span> <span class="dt">Ty</span></code></pre>
<p>We provide identity types and a primitive type of isomorphisms. If we were to have a bit fancier type theory, isomorphisms would be expressed using a combination of <span class="math">\(\Pi\)</span> and <span class="math">\(\Sigma\)</span> (rather than be a primitive construct).</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">      _≡_ <span class="fu">:</span> <span class="ot">∀</span> {<span class="dt">T</span> <span class="fu">:</span> <span class="dt">Ty</span>} (x y <span class="fu">:</span> <span class="dt">Tm</span> <span class="dt">T</span>) <span class="ot">→</span> <span class="dt">Ty</span>
      _≃_ <span class="fu">:</span> <span class="ot">∀</span> (<span class="dt">A</span> <span class="dt">B</span> <span class="fu">:</span> <span class="dt">Ty</span>) <span class="ot">→</span> <span class="dt">Ty</span></code></pre>
<p>For the sake of simplicity of presentation, our type system is impredicative. For our purposes, we only care about the first two universes anyway, so it is not too horrifying. We do a bit of gymnastics to reflect types into terms; so any term in the metalanguage in <code>Ty</code> can be reflected into a term in the object language of type <code>set</code> using <code>↓_</code>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="kw">infixr</span> <span class="dv">10</span> _,_
    <span class="kw">data</span> <span class="dt">Tm</span> <span class="fu">:</span> <span class="dt">Ty</span> <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span>
      ↓_ <span class="fu">:</span> <span class="dt">Ty</span> <span class="ot">→</span> <span class="dt">Tm</span> set
      _,_ <span class="fu">:</span> <span class="ot">∀</span> {<span class="dt">A</span> <span class="dt">B</span>} <span class="ot">→</span> <span class="dt">Tm</span> <span class="dt">A</span> <span class="ot">→</span> <span class="dt">Tm</span> <span class="dt">B</span> <span class="ot">→</span> <span class="dt">Tm</span> (<span class="dt">A</span> ⊗ <span class="dt">B</span>)</code></pre>
<p>We easily embed terms of our enumeration codes into our type system using <code>fin</code> and our term language using <code>[_]</code>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">      [_] <span class="fu">:</span> <span class="ot">∀</span> {e} (x <span class="fu">:</span> <span class="dt">EnumT</span> e) <span class="ot">→</span> <span class="dt">Tm</span> (fin e)</code></pre>
<p>Proofs of identity are introduced by reflexivity, and isomorphisms are given by two functions going either direction commuting to the identity.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">      refl <span class="fu">:</span> <span class="ot">∀</span> {<span class="dt">A</span> <span class="fu">:</span> <span class="dt">Ty</span>} {x <span class="fu">:</span> <span class="dt">Tm</span> <span class="dt">A</span>} <span class="ot">→</span> <span class="dt">Tm</span> (x ≡ x)
      iso <span class="fu">:</span> <span class="ot">∀</span> {<span class="dt">A</span> <span class="dt">B</span> <span class="fu">:</span> <span class="dt">Ty</span>}
              (f <span class="fu">:</span> <span class="dt">Tm</span> (<span class="dt">A</span> <span class="ot">⇒</span> <span class="dt">B</span>))
              (g <span class="fu">:</span> <span class="dt">Tm</span> (<span class="dt">B</span> <span class="ot">⇒</span> <span class="dt">A</span>))
              (α <span class="fu">:</span> <span class="ot">∀</span> x y <span class="ot">→</span> <span class="dt">Tm</span> (((f <span class="fu">#</span> (g <span class="fu">#</span> y)) ≡ y) ⊗ ((g <span class="fu">#</span> (f <span class="fu">#</span> x)) ≡ x))) <span class="ot">→</span>
              <span class="dt">Tm</span> (<span class="dt">A</span> ≃ <span class="dt">B</span>)</code></pre>
<p>Now, we can provide some cool axioms that compute! Trivially, equality implies isomorphism, but it’s also the case that for this universe, isomorphism implies equality! Now, since we’re just writing the typing rules here, we can say anything we like, but once we define what it means to be a function, and what it means to apply one, we can show that these really do compute.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">      equiv<span class="fu">-</span>to<span class="fu">-</span>path <span class="fu">:</span> <span class="ot">∀</span> {<span class="dt">A</span> <span class="dt">B</span> <span class="fu">:</span> <span class="dt">Ty</span>} <span class="ot">→</span> <span class="dt">Tm</span> (<span class="dt">A</span> ≃ <span class="dt">B</span>) <span class="ot">→</span> <span class="dt">Tm</span> (↓ <span class="dt">A</span> ≡ ↓ <span class="dt">B</span>)
      path<span class="fu">-</span>to<span class="fu">-</span>equiv <span class="fu">:</span> <span class="ot">∀</span> {<span class="dt">A</span> <span class="dt">B</span> <span class="fu">:</span> <span class="dt">Ty</span>} <span class="ot">→</span> <span class="dt">Tm</span> (↓ <span class="dt">A</span> ≡ ↓ <span class="dt">B</span>) <span class="ot">→</span> <span class="dt">Tm</span> (<span class="dt">A</span> ≃ <span class="dt">B</span>)</code></pre>
<p>Let’s go back and define functions for our universe of finite sets. Since we don’t need induction, we can actually just define functions as finite maps between sets; so, if a set has two terms, a function from that set to another set is just two terms in the codomain, and so on. We don’t provide any way to eliminate terms of types other than finite sets and products. And so the codomain is literally on its own, should one wish to make a function from, say, an identity type. There’s probably a better presentation, but it’s not the purpose of this demonstration.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="kw">infixr</span> <span class="dv">10</span> _<span class="ot">⇒</span>_
    _<span class="ot">⇒</span>_ <span class="fu">:</span> <span class="dt">Ty</span> <span class="ot">→</span> <span class="dt">Ty</span> <span class="ot">→</span> <span class="dt">Ty</span>
    fin [] <span class="ot">⇒</span> <span class="dt">B</span> <span class="fu">=</span> fin ‵one
    fin (x <span class="ot">∷</span> e) <span class="ot">⇒</span> <span class="dt">B</span> <span class="fu">=</span> <span class="dt">B</span> ⊗ ((fin e) <span class="ot">⇒</span> <span class="dt">B</span>)
    (<span class="dt">A</span> ⊗ <span class="dt">B</span>) <span class="ot">⇒</span> <span class="dt">C</span> <span class="fu">=</span> (<span class="dt">A</span> <span class="ot">⇒</span> <span class="dt">B</span> <span class="ot">⇒</span> <span class="dt">C</span>)
    _ <span class="ot">⇒</span> <span class="dt">B</span> <span class="fu">=</span> <span class="dt">B</span></code></pre>
<p>And now we can define function application, which is basically a recapitulation of our quirky definition of functions.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="kw">infixl</span> <span class="dv">10</span> _<span class="fu">#</span>_
    _<span class="fu">#</span>_ <span class="fu">:</span> <span class="ot">∀</span> {<span class="dt">A</span> <span class="dt">B</span> <span class="fu">:</span> <span class="dt">Ty</span>} (f <span class="fu">:</span> <span class="dt">Tm</span> (<span class="dt">A</span> <span class="ot">⇒</span> <span class="dt">B</span>)) (x <span class="fu">:</span> <span class="dt">Tm</span> <span class="dt">A</span>) <span class="ot">→</span> <span class="dt">Tm</span> <span class="dt">B</span>
    _<span class="fu">#</span>_ {fin []} _ [ () ]
    _<span class="fu">#</span>_ {fin (_ <span class="ot">∷</span> _)} (f , _) [ ‵0 ] <span class="fu">=</span> f
    _<span class="fu">#</span>_ {fin (_ <span class="ot">∷</span> _)} (_ , f) [ ‵1<span class="fu">+</span> x ] <span class="fu">=</span> f <span class="fu">#</span> [ x ]
    _<span class="fu">#</span>_ {_ ⊗ _} f (x , y) <span class="fu">=</span> f <span class="fu">#</span> x <span class="fu">#</span> y
    <span class="co">-- We don't provide elimninators for fancy types here.</span>
    _<span class="fu">#</span>_ {_ ≡ _} f _ <span class="fu">=</span> f
    _<span class="fu">#</span>_ {_ ≃ _} f _ <span class="fu">=</span> f
    _<span class="fu">#</span>_ {set} f _ <span class="fu">=</span> f</code></pre>
<p>The last bit of chores is to define <code>subst</code> for converting across equalities in the metalanguage (if we had induction for equality types, we could define it in the object language). In fact, this demonstrates that both isomorphisms and identities compute! We stop short of proving that isomorphism and equality are in fact isomorphic (univalence).</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  subst <span class="fu">:</span> <span class="ot">∀</span> {<span class="dt">A</span> <span class="dt">B</span> <span class="fu">:</span> <span class="dt">Ty</span>} (α <span class="fu">:</span> <span class="dt">Tm</span> (↓ <span class="dt">A</span> ≡ ↓ <span class="dt">B</span>)) <span class="ot">→</span> <span class="dt">Tm</span> <span class="dt">A</span> <span class="ot">→</span> <span class="dt">Tm</span> <span class="dt">B</span>
  subst {<span class="dt">A</span>} {<span class="fu">.</span><span class="dt">A</span>} refl x <span class="fu">=</span> x
  subst (equiv<span class="fu">-</span>to<span class="fu">-</span>path (iso f g α)) x <span class="fu">=</span> f <span class="fu">#</span> x
  subst (equiv<span class="fu">-</span>to<span class="fu">-</span>path (path<span class="fu">-</span>to<span class="fu">-</span>equiv p)) x <span class="fu">=</span> subst p x</code></pre>
<p>Now, we can see the main force our work. Let’s define a type of booleans using our enumeration codes:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  ‵bool <span class="fu">=</span> ‵<span class="st">&quot;true&quot;</span> <span class="ot">∷</span> ‵<span class="st">&quot;false&quot;</span> <span class="ot">∷</span> []
  bool <span class="fu">:</span> <span class="dt">Ty</span>
  bool <span class="fu">=</span> fin ‵bool

  ‵false ‵true <span class="fu">:</span> <span class="dt">EnumT</span> ‵bool
  ‵true <span class="fu">=</span> ‵0
  ‵false <span class="fu">=</span> ‵1<span class="fu">+</span> ‵0</code></pre>
<p>We can define two simple functions on booleans, the identity and negation:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="fu">id</span> <span class="fu">not</span> <span class="fu">:</span> <span class="dt">Tm</span> (bool <span class="ot">⇒</span> bool)
  <span class="fu">id</span> <span class="fu">=</span> [ ‵true ] , [ ‵false ] , [ ‵tt ]
  <span class="fu">not</span> <span class="fu">=</span> [ ‵false ] , [ ‵true ] , [ ‵tt ]</code></pre>
<p>In this universe, there is only one way to make equalities of base terms; but sets may have many equalities, given all the possibilities for isomorphism. For instance, the identity is of course an isomorphism, mapping between sets <code>{true, false}</code> and <code>{true, false}</code>; we can construct a proof that the set of booleans is equal to itself:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  bool≡bool<span class="fu">-id</span> <span class="fu">:</span> <span class="dt">Tm</span> (↓ bool ≡ ↓ bool)
  bool≡bool<span class="fu">-id</span> <span class="fu">=</span>
    equiv<span class="fu">-</span>to<span class="fu">-</span>path
      (iso <span class="fu">id</span> <span class="fu">id</span>
        (λ{ [ ‵0 ] [ ‵0 ] <span class="ot">→</span> refl , refl
          ; [ ‵0 ] [ ‵1<span class="fu">+</span> ‵0 ] <span class="ot">→</span> refl , refl
          ; [ ‵0 ] [ ‵1<span class="fu">+</span> (‵1<span class="fu">+</span> ()) ]
          ; [ ‵1<span class="fu">+</span> ‵0 ] [ ‵0 ] <span class="ot">→</span> refl , refl
          ; [ ‵1<span class="fu">+</span> ‵0 ] [ ‵1<span class="fu">+</span> ‵0 ] <span class="ot">→</span> refl , refl
          ; [ ‵1<span class="fu">+</span> ‵0 ] [ ‵1<span class="fu">+</span> (‵1<span class="fu">+</span> ()) ]
          ; [ ‵1<span class="fu">+</span> (‵1<span class="fu">+</span> ()) ] _ }))</code></pre>
<p>In addition, negation is an isomorphism, since it maps between <code>{true, false}</code> and <code>{false, true}</code>; so we can give a distinct proof that the set of booleans is equal to itself:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  bool≡bool<span class="fu">-not</span> <span class="fu">:</span> <span class="dt">Tm</span> (↓ bool ≡ ↓ bool)
  bool≡bool<span class="fu">-not</span> <span class="fu">=</span>
    equiv<span class="fu">-</span>to<span class="fu">-</span>path
      (iso <span class="fu">not</span> <span class="fu">not</span>
        (λ{ [ ‵0 ] [ ‵0 ] <span class="ot">→</span> refl , refl
          ; [ ‵0 ] [ ‵1<span class="fu">+</span> ‵0 ] <span class="ot">→</span> refl , refl
          ; [ ‵0 ] [ ‵1<span class="fu">+</span> (‵1<span class="fu">+</span> ()) ]
          ; [ ‵1<span class="fu">+</span> ‵0 ] [ ‵0 ] <span class="ot">→</span> refl , refl
          ; [ ‵1<span class="fu">+</span> ‵0 ] [ ‵1<span class="fu">+</span> ‵0 ] <span class="ot">→</span> refl , refl
          ; [ ‵1<span class="fu">+</span> ‵0 ] [ ‵1<span class="fu">+</span> (‵1<span class="fu">+</span> ()) ]
          ; [ ‵1<span class="fu">+</span> (‵1<span class="fu">+</span> ()) ] _ }))</code></pre>
<p>And the fun part is that when we <code>subst</code> our way across such proofs, our coercions actually compute, as follows:</p>
<pre><code>  subst-boolid : Tm (subst bool≡bool-id [ ‵true ] ≡ [ ‵true ])
  subst-boolid = refl

  subst-boolnot : Tm (subst bool≡bool-not [ ‵true ] ≡ [ ‵false ])
  subst-boolnot = refl</code></pre></article>
<h1>Want to comment?</h1>
<p> I’m @jonsterling on <a href="http://www.twitter.com/jonsterling">Twitter</a> and <a href="https://alpha.app.net/jonsterling">App.net</a>.</p>


<script src="//static.getclicky.com/js" type="text/javascript"></script>
<script type="text/javascript">try{ clicky.init(66625087);
    }catch(e){}</script>
<noscript><p><img alt="Clicky" width="1" height="1" src="//in.getclicky.com/66625087ns.gif" /></p></noscript>

<a rel="me" href="http://twitter.com/jonsterling"></a>
<a rel="me" href="https://alpha.app.net/jonsterling"></a>
</body>
</html>

