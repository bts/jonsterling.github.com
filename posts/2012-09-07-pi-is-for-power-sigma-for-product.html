<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="readability-verification" content="cG3MqZcEVveKZ6mnEFkePAL3Ug79Jxxp5Fn27CM7" />
<title>JS ⊢ Pi is for Power, Sigma for Product</title>
<link rel="stylesheet" type="text/css" href="../css/screen.css" />
<link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<link rel="stylesheet" type="text/css" href="../css/coqdoc.css" />
<style type="text/css">
    @import url(http://nmashton.ca/css/gloss-0.0.1.css);
</style>
<script type="text/javascript" src="http://code.jquery.com/jquery-1.8.3.min.js"></script>
<script type="text/javascript" src="http://nmashton.ca/js/gloss-0.0.1.js"></script>
<link rel="alternate" type="application/rss+xml" title="Jonathan Sterling" href="../rss.xml" />


<!--[if IE]>
  <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
<!--[if lte IE 7]>
  <script src="js/IE8.js" type="text/javascript"></script><![endif]-->
<!--[if lt IE 7]>
<link rel="stylesheet" type="text/css" media="all" href="css/ie6.css"/><![endif]-->

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  'HTML-CSS': {
    availableFonts: [],
    webFont: 'TeX'
  }
});
</script>
</head>
<body>

<header>
<h1><a href="../index.html"><span class="title">Pi is for Power, Sigma for Product.</span></a></h1>
</header>

<section class="post">
<article><p><span class="math">\(\prod\)</span> and <span class="math">\(\sum\)</span> are two fundamental connectives of <a href="http://en.wikipedia.org/wiki/Intuitionistic_type_theory">Intuitionistic Type Theory</a>, corresponding to <span class="math">\(\forall\)</span> and <span class="math">\(\exists\)</span> in logic respectively. In their non-dependent special cases, they represent cartesian powers and products respectively. Let’s take a look at how this works!</p>
<!--more-->

<h2 id="prod-generalizes-arrows-sum-generalizes-products"><span class="math">\(\prod\)</span> generalizes arrows, <span class="math">\(\sum\)</span> generalizes products</h2>
<p>Anyone who took elementary mathematics is probably aware that <span class="math">\(\prod\)</span> is the mathematical symbol for a product of a sequence; you’ve probably seen something like this: <span class="math">\[\begin{align}
    \prod_{i\in\mathbb{N}} f(i)
\end{align}\]</span>, the product of <span class="math">\(f(i)\)</span> over the set of all natural numbers <span class="math">\(\mathbb{N}\)</span>.</p>
<p>The word “product” gets us mistakenly thinking that a <span class="math">\(\prod\)</span>-type should be a pair or something, like <code>(,)</code> in Haskell. Consider the following function type for making a vector of ‘!’-characters of a given length in an Agda-like language with dependent types:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="fu">replicate</span> <span class="fu">:</span> (n<span class="fu">:</span>ℕ) <span class="ot">→</span> <span class="dt">Vect</span> n <span class="dt">Char</span> <span class="co">-- syntactic sugar</span>
<span class="fu">replicate</span> <span class="fu">:</span> Π(n<span class="fu">:</span>ℕ)<span class="fu">.</span> <span class="dt">Vect</span> n <span class="dt">Char</span> <span class="co">-- translated into ∏-notation</span>
<span class="fu">replicate</span> <span class="dv">0</span>     <span class="fu">=</span> []
<span class="fu">replicate</span> (n<span class="fu">+</span><span class="dv">1</span>) <span class="fu">=</span> <span class="ch">'!'</span><span class="ot"> ::</span> (<span class="fu">replicate</span> n)</code></pre>
<p>Most dependently-typed languages offer syntactic sugar to allow including terms inside the function-arrow syntax. In fact, we actually can see that for some type <code>P</code> which does not depend on <code>x</code>, <code>Π(x:T).P</code> is exactly equivalent to the plain function type <code>T → P</code>. So how is this really a product?</p>
<blockquote>
<p><strong>Though this be madness, yet there is method in’t!</strong> Let’s see what happens when we restrict our <span class="math">\(\prod\)</span>-operator to have the second element not depend on the first.</p>
</blockquote>
<p>Let’s look at a numerical example:</p>
<p><span class="math">\[\begin{align}
    f_x &amp;= C\\
    \prod_{i=0}^n f_i &amp;= f_0 \times f_1 \times f_2 \times \cdots \times f_n\\
                      &amp;= C^n
\end{align}\]</span></p>
<p>If <code>f</code> is constant over its input, then the multiplication can be collapsed into exponential notation. Now, the above example can be understood with an elementary understanding of grade-school numerical algebra; we can generalize it to hold for type algebra. But remember that an exponential type <span class="math">\(\beta^\alpha\)</span> is just a function type <span class="math">\(\alpha\to\beta\)</span>! One way to think of it is to say that it maps every <span class="math">\(\alpha\)</span> into <span class="math">\(\beta\)</span>-space.</p>
<p>Another way to think of it is to say that the codomain of a function is modelled by product of all the outputs of that function corresponding to the domain. For instance, consider the set <code>B</code> and some function <code>name</code> that maps bovines to strings:</p>
<p><span class="math">\[\begin{align}
\textbf{B} &amp;= \{ \text{Bessie}, \text{Brownie}, \text{Macy} \}\\
\textbf{name} &amp;\in \prod_{b\in\textbf{B}}.\ \textbf{String}\\
              &amp;\approx \textbf{String}^\textbf{B}\\
              &amp;\approx \textbf{B} \to \textbf{String}
\end{align}\]</span><!--___--></p>
<p>If we’d wanted to specify a function that mapped each bovine to its name paired with <em>that specific</em> bovine, we’d need to use a dependent type.</p>
<p>And so a <span class="math">\(\prod\)</span>-type is the (cartesian) product of all elements of its second component corresponding to its first component. In the case that the former is not dependent on the latter, this is a (cartesian) power: this is the space that functions of the second-order lambda calculus inhabit.</p>
<p>It’s much the same with <span class="math">\(\sum\)</span>-types. Let’s first take a numerical example:</p>
<p><span class="math">\[\begin{align}
    f_x &amp;= C\\
    \sum_{i=0}^n f_i &amp;= f_0 + f_1 + f_2 + \cdots + f_n\\
                     &amp;= C \times n
\end{align}\]</span></p>
<p>And so the sum of all the outputs, when the output set doesn’t depend on the input value, is just a product. Let’s look again at our bovine type to see how we can get pairs from this:</p>
<p><span class="math">\[\begin{align}
\textbf{name} &amp;\in \sum_{b\in\textbf{B}}.\ \textbf{String}\\
              &amp;\approx \textbf{String} \times \textbf{B}\\
\end{align}\]</span><!--__--></p>
<p>So, in this special non-dependent case, a <span class="math">\(\sum\)</span>-type is just a cartesian product (of bovines and strings): it specifies all possible pairs of bovines and string.</p>
<h2 id="realizing-prod-and-sum-in-agda">Realizing <span class="math">\(\prod\)</span> and <span class="math">\(\sum\)</span> in Agda</h2>
<p>I find that nothing helps me understand a concept better than a concrete example in a language I understand. I’ll be using <a href="http://wiki.portal.chalmers.se/agda/pmwiki.php">Agda</a> today, but the same task could have been done in most other dependent-typed languages, including <a href="http://idris-lang.org">Idris</a>.</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">SigmaPi</span> <span class="kw">where</span>

<span class="co">-- We use (dependent) records rather than plain-old data declarations</span>
<span class="co">-- because these conveniently provide accessors; an accessor for a</span>
<span class="co">-- Π-type corresponds to function application.</span>
record Π (α <span class="fu">:</span> <span class="dt">Set</span>) (β <span class="fu">:</span> α <span class="ot">→</span> <span class="dt">Set</span>) <span class="fu">:</span> <span class="dt">Set</span> <span class="kw">where</span>
  constructor Λ
  field _<span class="fu">$</span>_ <span class="fu">:</span> ((x <span class="fu">:</span> α) <span class="ot">→</span> β x)

record Σ (α <span class="fu">:</span> <span class="dt">Set</span>) (β <span class="fu">:</span> α <span class="ot">→</span> <span class="dt">Set</span>) <span class="fu">:</span> <span class="dt">Set</span> <span class="kw">where</span>
  constructor _,_
  field
    <span class="fu">fst</span> <span class="fu">:</span> α
    <span class="fu">snd</span> <span class="fu">:</span> β <span class="fu">fst</span>

<span class="co">-- A special case of Π: the function arrow.</span>
_<span class="fu">~&gt;</span>_ <span class="fu">:</span> <span class="dt">Set</span> <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">→</span> <span class="dt">Set</span>
_<span class="fu">~&gt;</span>_ α β <span class="fu">=</span> Π α (λ _ <span class="ot">→</span> β)

<span class="co">-- A special case of Σ: the cartesian product.</span>
_×_ <span class="fu">:</span> <span class="dt">Set</span> <span class="ot">→</span> <span class="dt">Set</span> <span class="ot">→</span> <span class="dt">Set</span>
_×_ α β <span class="fu">=</span> Σ α (λ _ <span class="ot">→</span> β)</code></pre>
<p>Now, we can test them to see how they work:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Tests</span> <span class="kw">where</span>
  open <span class="kw">import</span> Data.Char
  open <span class="kw">import</span> Relation.Binary.Core

  open Π
  open Σ

  <span class="kw">data</span> <span class="dt">Bovine</span> <span class="fu">:</span> <span class="dt">Set</span> <span class="kw">where</span>
    <span class="dt">Bessie</span>  <span class="fu">:</span> <span class="dt">Bovine</span>
    <span class="dt">Brownie</span> <span class="fu">:</span> <span class="dt">Bovine</span>
    <span class="dt">Macy</span>    <span class="fu">:</span> <span class="dt">Bovine</span>

  pair <span class="fu">:</span> ℕ × <span class="dt">Bovine</span>
  pair <span class="fu">=</span> <span class="dv">43</span> , <span class="dt">Macy</span>

  suc' <span class="fu">:</span> ℕ <span class="fu">~&gt;</span> ℕ
  suc' <span class="fu">=</span> Λ suc

  <span class="co">-- We can prove trivial equalities to test:</span>
  Σ-<span class="fu">fst-</span>test <span class="fu">:</span> <span class="fu">fst</span> pair ≡ <span class="dv">43</span>
  Σ-<span class="fu">fst-</span>test <span class="fu">=</span> refl

  Σ-<span class="fu">snd-</span>test <span class="fu">:</span> <span class="fu">snd</span> pair ≡ <span class="dt">Macy</span>
  Σ-<span class="fu">snd-</span>test <span class="fu">=</span> refl

  Π-application<span class="fu">-</span>test <span class="fu">:</span> suc' <span class="fu">$</span> <span class="dv">2</span> ≡ <span class="dv">3</span>
  Π-application<span class="fu">-</span>test <span class="fu">=</span> refl</code></pre>
<h2 id="coming-up-next-universe-polymorphism">Coming up next: Universe Polymorphism</h2>
<p>You may be wondering why I haven’t shown how to encode Haskell-style existentials; the problem is that they are actually impossible under the implementation I have given above. In the above implementation, the first part of the <span class="math">\(\sum\)</span> is a term of a type, but in order to forget (for instance) the type of a list’s elements, we’d need that first part to be a term of a kind. This calls for <em>universe polymorphism</em>, where the same code can be parameterized over universe levels; this will allow us to easily introduce Haskell-style existential types.</p></article>
<h1>Want to comment?</h1>
<p> I’m @jonsterling on <a href="http://www.twitter.com/jonsterling">Twitter</a> and <a href="https://alpha.app.net/jonsterling">App.net</a>.</p>


<script src="//static.getclicky.com/js" type="text/javascript"></script>
<script type="text/javascript">try{ clicky.init(66625087);
    }catch(e){}</script>
<noscript><p><img alt="Clicky" width="1" height="1" src="//in.getclicky.com/66625087ns.gif" /></p></noscript>

<a rel="me" href="http://twitter.com/jonsterling"></a>
<a rel="me" href="https://alpha.app.net/jonsterling"></a>
</body>
</html>

